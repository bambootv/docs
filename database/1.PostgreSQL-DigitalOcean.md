### PostgreSQL: Permission and backup (On Digital Ocean)

---

##### 1. Create Database

```sql
-- Ch·∫°y b·∫±ng user: doadmin

CREATE DATABASE my_database;

--- Revoke quy·ªÅn t·ª´ PUBLIC (B·∫£o m·∫≠t)
REVOKE CONNECT ON DATABASE _dodb FROM PUBLIC;
REVOKE CONNECT ON DATABASE defaultdb FROM PUBLIC;
REVOKE CONNECT ON DATABASE my_database FROM PUBLIC;

-- Connect to this database
-- Trong PostgreSQL, b·∫°n lu√¥n ph·∫£i k·∫øt n·ªëi ƒë·∫øn m·ªôt database ƒë·ªÉ th·ª±c thi c√¢u l·ªánh SQL.
-- Kh√¥ng c√≥ c√°ch n√†o ch·∫°y l·ªánh "kh√¥ng thu·ªôc database n√†o c·∫£".
\c my_database

-- Thu h·ªìi quy·ªÅn tr√™n schema public c·ªßa database my_database
REVOKE ALL ON SCHEMA public FROM PUBLIC;

-- Rollback above command
GRANT CONNECT ON DATABASE my_database TO PUBLIC;
```

```sql
-- Ki·ªÉm tra
SELECT
    'my_database' AS database_name,
    r.rolname AS user_role,
    COALESCE(BOOL_OR(privilege_type = 'CONNECT'), false) AS can_connect,
    COALESCE(BOOL_OR(privilege_type = 'CREATE'), false) AS can_create_schema,
    COALESCE(BOOL_OR(privilege_type = 'TEMPORARY'), false) AS can_create_temp_table,
    CASE
        WHEN COUNT(privilege_type) = 0 THEN 'Kh√¥ng c√≥ quy·ªÅn g√¨'
        ELSE 'C√≥ quy·ªÅn'
    END AS status
FROM pg_roles r
LEFT JOIN LATERAL (
    SELECT (aclexplode(datacl)).*
    FROM pg_database
    WHERE datname = 'my_database'
) acl ON acl.grantee = r.oid
WHERE r.rolname NOT LIKE 'pg_%'  -- B·ªè c√°c role h·ªá th·ªëng
GROUP BY r.rolname
ORDER BY
    COUNT(privilege_type) DESC,  -- User c√≥ quy·ªÅn l√™n tr∆∞·ªõc
    r.rolname;
```

###### L∆∞u √Ω

- ‚ö†Ô∏è B·∫ÆT BU·ªòC revoke quy·ªÅn t·ª´ PUBLIC
- ‚úÖ Ch·ªâ user ƒë∆∞·ª£c c·∫•p quy·ªÅn m·ªõi v√†o ƒë∆∞·ª£c database
- üîÑ L·∫∑p l·∫°i cho t·ª´ng database n·∫øu c√≥ nhi·ªÅu database

---

##### 2. Create User Full Permission

```sql
--- T·∫°o user v√† c·∫•p ƒë·∫ßy ƒë·ªß quy·ªÅn:
--- SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER

--- Ch·∫°y b·∫±ng: doadmin

CREATE USER my_full_user WITH PASSWORD 'StrongPassword123!';
ALTER USER my_full_user CONNECTION LIMIT 20;

GRANT CONNECT ON DATABASE my_database TO my_full_user;

\c my_database

GRANT USAGE ON SCHEMA public TO my_full_user;
GRANT CREATE ON SCHEMA public TO my_full_user;

GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO my_full_user;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO my_full_user;
GRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA public TO my_full_user;
GRANT ALL PRIVILEGES ON ALL ROUTINES IN SCHEMA public TO my_full_user;

ALTER DEFAULT PRIVILEGES IN SCHEMA public
    GRANT ALL ON TABLES TO my_full_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public
    GRANT ALL ON SEQUENCES TO my_full_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public
    GRANT ALL ON FUNCTIONS TO my_full_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public
    GRANT ALL ON ROUTINES TO my_full_user;

ALTER DEFAULT PRIVILEGES FOR ROLE doadmin IN SCHEMA public
    GRANT ALL ON TABLES TO my_full_user;
ALTER DEFAULT PRIVILEGES FOR ROLE doadmin IN SCHEMA public
    GRANT ALL ON SEQUENCES TO my_full_user;
ALTER DEFAULT PRIVILEGES FOR ROLE doadmin IN SCHEMA public
    GRANT ALL ON FUNCTIONS TO my_full_user;
ALTER DEFAULT PRIVILEGES FOR ROLE doadmin IN SCHEMA public
    GRANT ALL ON ROUTINES TO my_full_user;
```

```sql
-- Ki·ªÉm tra quy·ªÅn
SELECT
    datname as database_name,
    has_database_privilege('my_full_user', datname, 'CONNECT') as can_connect
FROM pg_database
WHERE datname NOT LIKE 'template%'
ORDER BY can_connect DESC, datname;
```

```sql
-- =====================================================
-- TEST MIGRATION SCRIPT
-- Ch·∫°y b·∫±ng user: my_full_user
-- Database: my_database
-- =====================================================

BEGIN; -- Start transaction ƒë·ªÉ c√≥ th·ªÉ rollback n·∫øu c·∫ßn

-- Test 1: CREATE TABLE v·ªõi nhi·ªÅu ki·ªÉu d·ªØ li·ªáu
CREATE TABLE test_migration (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    age INTEGER CHECK (age > 0),
    balance DECIMAL(10,2) DEFAULT 0.00,
    is_active BOOLEAN DEFAULT true,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP
);

-- Test 2: INSERT data
INSERT INTO test_migration (name, email, age, balance, metadata) VALUES
    ('User 1', 'user1@test.com', 25, 100.50, '{"role": "admin"}'::jsonb),
    ('User 2', 'user2@test.com', 30, 200.75, '{"role": "user"}'::jsonb),
    ('User 3', 'user3@test.com', 35, 300.00, '{"role": "user"}'::jsonb);

-- Test 3: CREATE INDEX
CREATE INDEX idx_test_name ON test_migration(name);
CREATE INDEX idx_test_email ON test_migration(email);
CREATE INDEX idx_test_metadata ON test_migration USING GIN(metadata);

-- Test 4: ALTER TABLE (th√™m/s·ª≠a column)
ALTER TABLE test_migration ADD COLUMN phone VARCHAR(20);
ALTER TABLE test_migration ADD COLUMN address TEXT;
ALTER TABLE test_migration ALTER COLUMN balance SET DEFAULT 1000.00;

-- Test 5: UPDATE data
UPDATE test_migration SET phone = '0123456789' WHERE id = 1;
UPDATE test_migration SET address = 'Ha Noi' WHERE email LIKE '%test.com';

-- Test 6: SELECT v·ªõi JOIN, WHERE, ORDER BY
SELECT * FROM test_migration WHERE age > 25 ORDER BY created_at DESC;

-- Test 7: DELETE data
DELETE FROM test_migration WHERE id = 3;

-- Test 8: CREATE SEQUENCE ri√™ng
CREATE SEQUENCE test_seq START 1000;
SELECT nextval('test_seq');
SELECT currval('test_seq');

-- Test 9: CREATE FUNCTION
CREATE OR REPLACE FUNCTION test_function()
RETURNS INTEGER AS $$
BEGIN
    RETURN 42;
END;
$$ LANGUAGE plpgsql;

SELECT test_function();

-- Test 10: Cleanup
DROP FUNCTION test_function();
DROP SEQUENCE test_seq;
DROP TABLE test_migration CASCADE;

COMMIT; -- Ho·∫∑c ROLLBACK; n·∫øu mu·ªën h·ªßy

-- =====================================================
-- N·∫æU T·∫§T C·∫¢ CH·∫†Y TH√ÄNH C√îNG ‚Üí ƒê·ª¶ QUY·ªÄN CHO MIGRATION! ‚úÖ
-- =====================================================
```

###### L∆∞u √Ω

- ‚úÖ User c√≥ FULL quy·ªÅn g·∫ßn nh∆∞ owner
- ‚ö†Ô∏è B·∫ÆT BU·ªòC set DEFAULT PRIVILEGES cho doadmin
- üîê Password n√™n m·∫°nh (‚â• 16 k√Ω t·ª±)
- üìä Connection limit 20 ƒë·ªß cho production

---

##### 3. Create Limit Permission User

```sql
-- Ch·∫°y b·∫±ng user: doadmin
CREATE USER my_readonly_user WITH PASSWORD 'ReadOnlyPass456!';
ALTER USER my_readonly_user CONNECTION LIMIT 10;

GRANT CONNECT ON DATABASE my_database TO my_readonly_user;
\c my_database

-- Readonly full table
GRANT USAGE ON SCHEMA public TO my_readonly_user;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO my_readonly_user;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO my_readonly_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO my_readonly_user;

ALTER DEFAULT PRIVILEGES IN SCHEMA public
    GRANT SELECT ON TABLES TO my_readonly_user;

ALTER DEFAULT PRIVILEGES FOR ROLE doadmin IN SCHEMA public
    GRANT SELECT ON TABLES TO my_readonly_user;

-- Specific table
-- ALL PRIVILEGES => SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER
GRANT ALL PRIVILEGES ON attendance_logs TO my_limited_user;
-- C·∫•p ALL PRIVILEGES tr√™n sequence (ƒë·ªÉ INSERT v·ªõi id t·ª± tƒÉng)
SELECT pg_get_serial_sequence('public.attendance_logs', 'id'); -- K·∫øt qu·∫£: public.attendance_logs_id_seq
GRANT ALL PRIVILEGES ON SEQUENCE public.attendance_logs_id_seq TO my_limited_user;
```

```sql
-- Ki·ªÉm tra quy·ªÅn
SELECT
    datname as database_name,
    has_database_privilege('my_limited_user', datname, 'CONNECT') as can_connect
FROM pg_database
WHERE datname NOT LIKE 'template%'
ORDER BY can_connect DESC, datname;

SELECT
    schemaname AS schema,
    tablename AS table_name,
    COALESCE(BOOL_OR(privilege_type = 'SELECT'), false) AS can_select,
    COALESCE(BOOL_OR(privilege_type = 'INSERT'), false) AS can_insert,
    COALESCE(BOOL_OR(privilege_type = 'UPDATE'), false) AS can_update,
    COALESCE(BOOL_OR(privilege_type = 'DELETE'), false) AS can_delete,
    COALESCE(BOOL_OR(privilege_type = 'TRUNCATE'), false) AS can_truncate,
    COALESCE(BOOL_OR(privilege_type = 'REFERENCES'), false) AS can_references,
    COALESCE(BOOL_OR(privilege_type = 'TRIGGER'), false) AS can_trigger,
    CASE
        WHEN COUNT(privilege_type) = 0 THEN 'Kh√¥ng c√≥ quy·ªÅn'
        WHEN COUNT(DISTINCT privilege_type) >= 7 THEN 'Full quy·ªÅn'
        WHEN BOOL_OR(privilege_type = 'SELECT') THEN 'Ch·ªâ ƒë·ªçc/m·ªôt s·ªë quy·ªÅn'
        ELSE 'M·ªôt s·ªë quy·ªÅn'
    END AS status
FROM pg_tables t
LEFT JOIN LATERAL aclexplode(
    COALESCE(
        (SELECT relacl FROM pg_class WHERE relname = t.tablename AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = t.schemaname)),
        '{}'::aclitem[]
    )
) acl ON acl.grantee = (SELECT oid FROM pg_roles WHERE rolname = 'my_limited_user')
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')  -- B·ªè system schema
GROUP BY schemaname, tablename
ORDER BY
    schemaname,
    COUNT(privilege_type) DESC,
    tablename;
```

---

##### 4. Backup & Restore

```bash
# Dump
PGPASSWORD="<password>" pg_dump \
    -h <db_host> \
    -p <db_port> \
    -U <db_user> \
    -d <db_database> \
    -t <db_table> \
    -F p \
    --no-owner \
    --no-privileges \
    -f ./data_bak_01_01_2025.sql

# Restore
PGPASSWORD="<password>" PGSSLMODE=require psql \
    -h <db_host> \
    -p <db_port> \
    -U <db_user> \
    -d <db_database> \
    -f ./data_bak_01_01_2025.sql

# -F p: -F = format, p = plain text SQL. N√™n -F p = xu·∫•t file dump d∆∞·ªõi d·∫°ng SQL thu·∫ßn, c√≥ th·ªÉ m·ªü b·∫±ng editor v√† ch·∫°y b·∫±ng psql.
# --no-owner: Kh√¥ng ƒë·∫∑t OWNER cho table, sequence, view, function... khi dump, gi√∫p restore an to√†n h∆°n ·ªü m√¥i tr∆∞·ªùng kh√°c.
# --no-privileges: kh√¥ng export GRANT/REVOKE, gi√∫p file dump ‚Äús·∫°ch‚Äù h∆°n v√† tr√°nh l·ªói permission khi restore. (--clean: Drop table, -s: Schema only)
```

##### 5. Fix Bug: Permission denied for schema public

```sql
# Login as supper user
GRANT CREATE, USAGE ON SCHEMA public TO <db_user>;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO <db_user>;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO <db_user>;
```
